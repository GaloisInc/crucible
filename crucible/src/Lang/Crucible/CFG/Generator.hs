------------------------------------------------------------------------
-- |
-- Module           : Lang.Crucible.CFG.Generator
-- Description      : Provides a monadic interface for constructing Crucible
--                    control flow graphs.
-- Copyright        : (c) Galois, Inc 2014
-- License          : BSD3
-- Maintainer       : Joe Hendrix <jhendrix@galois.com>
-- Stability        : provisional
--
-- This module provides a monadic interface for constructing control flow
-- graph expressions.  The goal is to make it easy to convert languages
-- into CFGs.
--
-- The CFGs generated by this interface are similar to, but not quite the
-- same as, the CFGs defined in Lang.Crucible.Core.  The the module
-- Lang.Crucible.SSAConversion contains code that converts the CFGs produced
-- by this interface into Core CFGs in SSA form.
------------------------------------------------------------------------
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DoAndIfThenElse #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeOperators #-}
module Lang.Crucible.CFG.Generator
  ( -- * Generator
    Generator
  , getPosition
  , setPosition
  , withPosition
  , readGlobal
  , writeGlobal
  , newReg
  , newUnassignedReg
  , newUnassignedReg'
  , readReg
  , assignReg
  , modifyReg
  , modifyRegM
  , forceEvaluation
  , addPrintStmt
  , call
  , mkAtom
  , recordCFG
  , FunctionDef
  , defineFunction
    -- * Low-level terminal expressions.
  , End
  , endNow
  , newLabel
  , newLambdaLabel
  , newLambdaLabel'
  , endCurrentBlock
  , defineBlock
  , defineLambdaBlock
  , resume
  , resume_
  , branch
    -- * Combinators
  , jump
  , jumpToLambda
  , returnFromFunction
  , reportError
  , whenCond
  , unlessCond
  , assertExpr
  , ifte
  , ifte_
  , ifteM
  , MatchMaybe(..)
  , caseMaybe
  , caseMaybe_
  , fromJustExpr
  , assertedJustExpr
  , while
  -- * Re-exports
  , Ctx.Ctx(..)
  , Position
  , module Lang.Crucible.CFG.Reg
  ) where

import           Control.Lens hiding (Index)
import           Control.Monad.State.Strict
import qualified Data.Foldable as Fold
import           Data.Maybe
import           Data.Parameterized.Context as Ctx
import           Data.Parameterized.Some
import           Data.Parameterized.TraversableFC
import           Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import qualified Data.Set as Set

import           Lang.Crucible.CFG.Core (AnyCFG(..), GlobalVar(..))
import           Lang.Crucible.CFG.Expr(App(..))
import           Lang.Crucible.CFG.Reg
import           Lang.Crucible.FunctionHandle
import           Lang.Crucible.ProgramLoc
import           Lang.Crucible.Types
import           Lang.Crucible.Utils.MonadST
import           Lang.Crucible.Utils.StateContT

------------------------------------------------------------------------
-- CurrentBlockState

-- | A sequence of statements.
type StmtSeq s = Seq (Posd (Stmt s))

-- | Information about block being generated in Generator.
data CurrentBlockState s
   = CBS { -- | Identifier for current block
           cbsBlockID       :: !(BlockID s)
         , cbsInputValues   :: !(ValueSet s)
         , _cbsStmts        :: !(StmtSeq s)
         }

initCurrentBlockState :: ValueSet s -> BlockID s -> CurrentBlockState s
initCurrentBlockState inputs block_id =
  CBS { cbsBlockID     = block_id
      , cbsInputValues = inputs
      , _cbsStmts      = Seq.empty
      }

-- | Statements translated so far in this block.
cbsStmts :: Simple Lens (CurrentBlockState s) (StmtSeq s)
cbsStmts = lens _cbsStmts (\s v -> s { _cbsStmts = v })

------------------------------------------------------------------------
-- GeneratorState

-- | State for translating within a basic block.
data GeneratorState s (t :: * -> *) ret
   = GS { _gsBlocks    :: !(Seq (Block s ret))
        , _gsNextLabel :: !Int
        , _gsNextValue :: !Int
        , _gsCurrent   :: !(Maybe (CurrentBlockState s))
        , _gsPosition  :: !Position
        , _gsState     :: !(t s)
        , _seenFunctions :: ![AnyCFG]
        }

-- | List of previously processed blocks.
gsBlocks :: Simple Lens (GeneratorState s t ret) (Seq (Block s ret))
gsBlocks = lens _gsBlocks (\s v -> s { _gsBlocks = v })

-- | Index of next label.
gsNextLabel :: Simple Lens (GeneratorState s t ret) Int
gsNextLabel = lens _gsNextLabel (\s v -> s { _gsNextLabel = v })

-- | Index used for register and atom identifiers.
gsNextValue :: Simple Lens (GeneratorState s t ret) Int
gsNextValue = lens _gsNextValue (\s v -> s { _gsNextValue = v })

-- | Information about current block.
gsCurrent :: Simple Lens (GeneratorState s t ret) (Maybe (CurrentBlockState s))
gsCurrent = lens _gsCurrent (\s v -> s { _gsCurrent = v })

-- | Current Statements translated so far in this block.
gsPosition :: Simple Lens (GeneratorState s t ret) Position
gsPosition = lens _gsPosition (\s v -> s { _gsPosition = v })

-- | State for current block.  This gets reset between blocks.
gsState :: Simple Lens (GeneratorState s t ret) (t s)
gsState = lens _gsState (\s v -> s { _gsState = v })

-- | List of functions seen by current generator.
seenFunctions :: Simple Lens (GeneratorState s t r) [AnyCFG]
seenFunctions = lens _seenFunctions (\s v -> s { _seenFunctions = v })

checkCurrentUnassigned :: MonadState (GeneratorState s t ret) m => m ()
checkCurrentUnassigned = do
  mc <- use gsCurrent
  when (isJust mc) $ do
    error "Current block is still assigned."

------------------------------------------------------------------------
-- Generator

-- | A generator is used for constructing a CFG from a sequence of
-- monadic actions.
--
-- It wraps the 'ST' monad to allow clients to create references, and
-- has a phantom type parameter to prevent constructs from different
-- CFGs from being mixed.
--
-- The 'h' parameter is the parameter for the underlying ST monad.
-- The 's' parameter is the phantom parameter for CFGs.
-- The 't' parameter is the parameterized type that allows user-defined
-- state.  It is reset at each block.
-- The 'ret' parameter is the return type of the CFG.
-- The 'a' parameter is the value returned by the monad.
newtype Generator h s t ret a
      = Generator { unGenerator :: StateContT (GeneratorState s t ret)
                                              (GeneratorState s t ret)
                                              (ST h)
                                              a
                  }
  deriving ( Functor
           , Applicative
           , MonadST h
           )

instance Monad (Generator h s t ret) where
  return  = Generator . return
  x >>= f = Generator (unGenerator x >>= unGenerator . f)
  fail msg = Generator $ do
     p <- use gsPosition
     fail $ "at " ++ show p ++ ": " ++ msg

instance MonadState (t s) (Generator h s t ret) where
  get = Generator $ use gsState
  put v = Generator $ gsState .= v

-- | Get the current position.
getPosition :: Generator h s t ret Position
getPosition = Generator $ use gsPosition

-- | Set the current position.
setPosition :: Position -> Generator h s t ret ()
setPosition p = Generator $ gsPosition .= p

-- | Set the current position temporarily, and reset it afterwards.
withPosition :: Position
             -> Generator h s t ret a
             -> Generator h s t ret a
withPosition p m = do
  old_pos <- getPosition
  setPosition p
  v <- m
  setPosition old_pos
  return v

freshValueIndex :: MonadState (GeneratorState s t ret) m => m Int
freshValueIndex = do
  n <- use gsNextValue
  gsNextValue .= n+1
  return n

newUnassignedReg'' :: MonadState (GeneratorState s r ret) m => TypeRepr tp -> m (Reg s tp)
newUnassignedReg'' tp = do
  p <- use gsPosition
  n <- freshValueIndex
  return $! Reg { regPosition = p
                , regId = n
                , typeOfReg = tp
                }

addStmt :: MonadState (GeneratorState s t ret) m => Stmt s -> m ()
addStmt s = do
  p <- use gsPosition
  Just cbs <- use gsCurrent
  let ps = Posd p s
  seq ps $ do
  let cbs' = cbs & cbsStmts %~ (Seq.|> ps)
  seq cbs' $ gsCurrent .= Just cbs'

freshAtom :: AtomValue s tp -> Generator h s t ret (Atom s tp)
freshAtom av = Generator $ do
  p <- use gsPosition
  i <- freshValueIndex
  let atom = Atom { atomPosition = p
                  , atomId = i
                  , atomSource = Assigned
                  , typeOfAtom = typeOfAtomValue av
                  }
  addStmt $ DefineAtom atom av
  return atom

-- | Create an atom equivalent to the given expression if it is
-- not already an atom.
mkAtom :: Expr s tp  -> Generator h s t ret (Atom s tp)
mkAtom (AtomExpr a)   = return a
mkAtom (App a)        = freshAtom . EvalApp =<< traverseFC mkAtom a

-- | Generate a new virtual register with the given initial value.
newReg :: Expr s tp -> Generator h s t ret (Reg s tp)
newReg e = do
  a <- mkAtom e
  Generator $ do
    r <- newUnassignedReg'' (typeOfAtom a)
    addStmt (SetReg r a)
    return r

-- | Read a global variable
readGlobal :: GlobalVar tp -> Generator h s t ret (Expr s tp)
readGlobal v = AtomExpr <$> freshAtom (ReadGlobal v)

-- | Write to a global variable
writeGlobal :: GlobalVar tp -> Expr s tp -> Generator h s t ret ()
writeGlobal v e = do
  a <-  mkAtom e
  Generator $ addStmt $ WriteGlobal v a

-- | Produce a new virtual register without giving it an initial value.
--   NOTE! If you fail to initialize this register with a subsequent
--   call to @assignReg@, errors will arise during SSA conversion.
newUnassignedReg' :: TypeRepr tp -> End h s t ret (Reg s tp)
newUnassignedReg' tp = End $ newUnassignedReg'' tp

-- | Produce a new virtual register without giving it an initial value.
--   NOTE! If you fail to initialize this register with a subsequent
--   call to @assignReg@, errors will arise during SSA conversion.
newUnassignedReg :: TypeRepr tp -> Generator h s t ret (Reg s tp)
newUnassignedReg tp = Generator $ newUnassignedReg'' tp

-- | Get value of register at current time.
readReg :: Reg s tp -> Generator h s t ret (Expr s tp)
readReg r = AtomExpr <$> freshAtom (ReadReg r)

-- | Update the value of a register.
assignReg :: Reg s tp -> Expr s tp -> Generator h s t ret ()
assignReg r e = do
  a <-  mkAtom e
  Generator $ addStmt $ SetReg r a

-- | Modify the value of a register.
modifyReg :: Reg s tp -> (Expr s tp -> Expr s tp) -> Generator h s t ret ()
modifyReg r f = do
  v <- readReg r
  assignReg r $! f v

-- | Modify the value of a register.
modifyRegM :: Reg s tp
           -> (Expr s tp -> Generator h s t ret (Expr s tp))
           -> Generator h s t ret ()
modifyRegM r f = do
  v <- readReg r
  v' <- f v
  assignReg r v'

-- | Add a statement to print a value.
addPrintStmt :: Expr s StringType -> Generator h s t ret ()
addPrintStmt e = do
  e_a <- mkAtom e
  Generator $ addStmt (Print e_a)

-- | Add an assert stmt to the generator.
assertExpr :: Expr s BoolType -> Expr s StringType -> Generator h s t ret ()
assertExpr b e = do
  b_a <- mkAtom b
  e_a <- mkAtom e
  Generator $ addStmt $ Assert b_a e_a

-- | Stash the given CFG away for later retrieval.  This is primarily
--   used when translating inner and anonymous functions in the
--   context of an outer function.
recordCFG :: AnyCFG -> Generator h s t ret ()
recordCFG g = Generator $ seenFunctions %= (g:)

------------------------------------------------------------------------
-- End

-- | A low-level interface for defining transitions between basic-blocks.
--
-- The 'h' parameter is the ST index used for 'ST h'
-- The 's' parameter is part of the CFG.
-- The 't' is parameter is for the user-defined state.
-- The 'ret' parameter is the return type for the CFG.
newtype End h s t ret a = End { unEnd :: StateT (GeneratorState s t ret) (ST h) a }
  deriving ( Functor
           , Applicative
           , Monad
           , MonadST h
           )

instance MonadState (t s) (End h s t ret) where
  get = End (use gsState)
  put x = End (gsState .= x)

-- | End the current translation.
endNow :: ((a -> End h s t ret ())
          -> End h s t ret ())
       -> Generator h s t ret a
endNow m = Generator $ StateContT $ \c ts -> do
  let f v = End $ do
        s <- get
        put =<< liftST (c v s)
  execStateT (unEnd (m f)) ts

-- | Create a new block label
newLabel :: End h s t ret (Label s)
newLabel = End $ do
  idx <- use gsNextLabel
  gsNextLabel .= idx + 1
  return (Label idx)

-- | Create a new lambda label
newLambdaLabel :: KnownRepr TypeRepr tp => End h s t ret (LambdaLabel s tp)
newLambdaLabel = newLambdaLabel' knownRepr

newLambdaLabel' :: TypeRepr tp -> End h s t ret (LambdaLabel s tp)
newLambdaLabel' tpr = End $ do
  p <- use gsPosition
  idx <- use gsNextLabel
  gsNextLabel .= idx + 1

  i <- freshValueIndex

  let lbl = LambdaLabel idx a
      a = Atom { atomPosition = p
               , atomId = i
               , atomSource = LambdaArg lbl
               , typeOfAtom = tpr
               }
  return $! lbl

-- | Define the current block by defining the position and
-- final statement.  This returns the user state after the
-- block is finished.
endCurrentBlock :: TermStmt s ret
                -> End h s t ret ()
endCurrentBlock term = End $ do
  gs <- get
  let p = gs^.gsPosition
  let Just cbs = gs^.gsCurrent
  -- Clear current state.
  gsCurrent .= Nothing
  -- Define block
  let b = mkBlock (cbsBlockID cbs) (cbsInputValues cbs) (cbs^.cbsStmts) (Posd p term)
  -- Store block
  seq b $ do
  gsBlocks %= (Seq.|> b)

-- | Resume execution by jumping to a label.
resume_  :: Label s -- ^ Label to jump to.
         -> (() -> End h s t ret ())
            -- ^ Continuation to run.
         -> End h s t ret ()
resume_ lbl c = End $ do
  checkCurrentUnassigned
  gsCurrent .= Just (initCurrentBlockState Set.empty (LabelID lbl))
  unEnd $ c ()

-- | Resume execution by jumping to a lambda label
resume :: LambdaLabel s r
          -- ^ Label to jump to.
       -> (Expr s r -> End h s t ret ())
          -- ^ Continuation to run.
       -> End h s t ret ()
resume lbl c = End $ do
  let block_id = LambdaID lbl
  checkCurrentUnassigned
  gsCurrent .= Just (initCurrentBlockState Set.empty block_id)
  unEnd $ c (AtomExpr (lambdaAtom lbl))

defineSomeBlock :: BlockID s
                -> Generator h s t ret ()
                -> End h s t ret ()
defineSomeBlock l next = End $ do
  gs <- get
  let gs_next = gs & gsCurrent .~ Just (initCurrentBlockState Set.empty l)
  let c_next _ gs' =
        let p' = gs'^.gsPosition
         in error $ "Block at " ++ show p' ++ " ended without terminating."
  gs' <- liftST $ runStateContT (unGenerator next) c_next gs_next
  -- Reset current block and state.
  put $ gs' & gsCurrent  .~ gs^.gsCurrent
            & gsPosition .~ gs^.gsPosition
            & gsState    .~ gs^.gsState

-- | Define a block with an ordinary label.
defineBlock :: Label s
            -> Generator h s t ret ()
            -> End h s t ret ()
defineBlock l next =
  defineSomeBlock (LabelID l) next

-- | Define a block that has a lambda label
defineLambdaBlock :: LambdaLabel s i
                  -> (Expr s i -> Generator h s t ret ())
                  -> End h s t ret ()
defineLambdaBlock l next = do
  let block_id = LambdaID l
  defineSomeBlock block_id $ next (AtomExpr (lambdaAtom l))

------------------------------------------------------------------------
-- Generator interface

-- | Evaluate an expression, so that it can be more efficiently evaluated later.
forceEvaluation :: Expr s tp -> Generator h s t ret (Expr s tp)
forceEvaluation e = AtomExpr <$> mkAtom e

-- | Call a function.
call :: Expr s (FunctionHandleType args ret)
        -> Assignment (Expr s) args
        -> Generator h s t r (Expr s ret)
call h args = AtomExpr <$> call' h args

-- | Call a function.
call' :: Expr s (FunctionHandleType args ret)
        -> Assignment (Expr s) args
        -> Generator h s t r (Atom s ret)
call' h args = do
  case exprType h of
    FunctionHandleRepr _ retType -> do
      h_a <- mkAtom h
      args_a <- traverseFC mkAtom args
      freshAtom $ Call h_a args_a retType

-- | Jump to given label.
jump :: Label s -> Generator h s t ret a
jump l = do
  endNow $ \_ -> do
    endCurrentBlock (Jump l)

-- | Jump to label with output.
jumpToLambda :: LambdaLabel s tp -> Expr s tp -> Generator h s t ret a
jumpToLambda lbl v = do
  v_a <- mkAtom v
  endNow $ \_ -> do
    endCurrentBlock (Output lbl v_a)

-- | Branch between blocks, returns label of this block.
branch :: Expr s BoolType
       -> Label s
       -> Label s
       -> Generator h s t ret a
branch (App (Not e)) x_id y_id = do
  branch e y_id x_id
branch e x_id y_id = do
  a <- mkAtom e
  endNow $ \_ -> do
    endCurrentBlock (Br a x_id y_id)

------------------------------------------------------------------------
-- Combinators

-- | Return from this function.
returnFromFunction :: Expr s ret -> Generator h s t ret a
returnFromFunction e = do
  e_a <- mkAtom e
  endNow $ \_ -> do
    endCurrentBlock (Return e_a)

-- | Report error message.
reportError :: Expr s StringType -> Generator h s t ret a
reportError e = do
  e_a <- mkAtom e
  endNow $ \_ -> do
    endCurrentBlock (ErrorStmt e_a)

-- | If-then-else. The first action if the 'true' branch, the second of the
-- 'false' branch. See 'Br' in "Lang.Crucible.Core".
ifte :: KnownRepr TypeRepr tp
     => Expr s BoolType
     -> Generator h s t ret (Expr s tp)
     -> Generator h s t ret (Expr s tp)
     -> Generator h s t ret (Expr s tp)
ifte e x y = do
  e_a <- mkAtom e
  endNow $ \c -> do
    x_id <- newLabel
    y_id <- newLabel
    c_id <- newLambdaLabel

    endCurrentBlock (Br e_a x_id y_id)
    defineBlock x_id $ x >>= jumpToLambda c_id
    defineBlock y_id $ y >>= jumpToLambda c_id
    resume c_id c

ifteM :: KnownRepr TypeRepr tp
     => Generator h s t ret (Expr s BoolType)
     -> Generator h s t ret (Expr s tp)
     -> Generator h s t ret (Expr s tp)
     -> Generator h s t ret (Expr s tp)
ifteM em x y = do { m <- em; ifte m x y }

ifte_ :: Expr s BoolType
      -> Generator h s t ret ()
      -> Generator h s t ret ()
      -> Generator h s t ret ()
ifte_ e x y = do
  e_a <- mkAtom e
  endNow $ \c -> do
    x_id <- newLabel
    y_id <- newLabel
    c_id <- newLabel

    endCurrentBlock (Br e_a x_id y_id)
    defineBlock x_id $ x >> jump c_id
    defineBlock y_id $ y >> jump c_id
    resume_ c_id c

-- | Run a computation when a condition is false.
whenCond :: Expr s BoolType
         -> Generator h s t ret ()
         -> Generator h s t ret ()
whenCond e x = do
  e_a <- mkAtom e
  endNow $ \c -> do
    t_id <- newLabel
    c_id <- newLabel

    endCurrentBlock $! Br e_a t_id c_id
    defineBlock t_id $ x >> jump c_id
    resume_ c_id c

-- | Run a computation when a condition is false.
unlessCond :: Expr s BoolType
           -> Generator h s t ret ()
           -> Generator h s t ret ()
unlessCond e x = do
  e_a <- mkAtom e
  endNow $ \c -> do
    f_id <- newLabel
    c_id <- newLabel

    endCurrentBlock  $ Br e_a c_id f_id
    defineBlock f_id $ x >> jump c_id
    resume_ c_id c

data MatchMaybe j r
   = MatchMaybe
   { onJust :: j -> r
   , onNothing :: r
   }

caseMaybe :: Expr s (MaybeType tp)
          -> TypeRepr r
          -> MatchMaybe (Expr s tp) (Generator h s t ret (Expr s r))
          -> Generator h s t ret (Expr s r)
caseMaybe v retType cases = do
  v_a <- mkAtom v
  let etp = case exprType v of
              MaybeRepr etp' -> etp'
  endNow $ \c -> do
    j_id <- newLambdaLabel' etp
    n_id <- newLabel
    c_id <- newLambdaLabel' retType

    endCurrentBlock $ MaybeBranch etp v_a j_id n_id
    defineLambdaBlock j_id $ onJust cases >=> jumpToLambda c_id
    defineBlock       n_id $ onNothing cases >>= jumpToLambda c_id
    resume c_id c

caseMaybe_ :: Expr s (MaybeType tp)
           -> MatchMaybe (Expr s tp) (Generator h s t ret ())
           -> Generator h s t ret ()
caseMaybe_ v cases = do
  v_a <- mkAtom v
  let etp = case exprType v of
              MaybeRepr etp' -> etp'
  endNow $ \c -> do
    j_id <- newLambdaLabel' etp
    n_id <- newLabel
    c_id <- newLabel

    endCurrentBlock $ MaybeBranch etp v_a j_id n_id
    defineLambdaBlock j_id $ \e -> onJust cases e >> jump c_id
    defineBlock       n_id $ onNothing cases >> jump c_id
    resume_ c_id c

fromJustExpr :: Expr s (MaybeType tp)
             -> Expr s StringType
             -> Generator h s t ret (Expr s tp)
fromJustExpr e msg = do
  let etp = case exprType e of
              MaybeRepr etp' -> etp'
  caseMaybe e etp MatchMaybe
    { onJust = return
    , onNothing = reportError msg
    }

-- | This asserts that the value in the expression is a just value, and
-- returns the underlying value.
assertedJustExpr :: Expr s (MaybeType tp)
                 -> Expr s StringType
                 -> Generator h s t ret (Expr s tp)
assertedJustExpr e msg =
  case exprType e of
    MaybeRepr tp ->
      forceEvaluation $! App (FromJustValue tp e msg)

while :: (Position, Generator h s t ret (Expr s BoolType))
      -> (Position, Generator h s t ret ())
      -> Generator h s t ret ()
while (pcond,cond) (pbody,body) = do
  endNow $ \cont -> do
    cond_lbl <- newLabel
    loop_lbl <- newLabel
    exit_lbl <- newLabel

    p <- End $ use gsPosition
    endCurrentBlock (Jump cond_lbl)

    End $ gsPosition .= pcond
    defineBlock cond_lbl $ do
      b <- cond
      branch b loop_lbl exit_lbl

    End $ gsPosition .= pbody
    defineBlock loop_lbl $ do
      body
      jump cond_lbl
    -- Reset position
    End $ gsPosition .= p
    resume_ exit_lbl cont

------------------------------------------------------------------------
-- CFG

cfgFromGenerator :: FnHandle init ret
                 -> GeneratorState s t ret
                 -> CFG s init ret
cfgFromGenerator h s =
  CFG { cfgHandle = h
      , cfgBlocks = Fold.toList (s^.gsBlocks)
      }

-- | Given the arguments, this returns the initial state, and an action for
-- computing the return value
type FunctionDef h t init ret
   = forall s
   . Assignment (Atom s) init
     -> (t s, Generator h s t ret (Expr s ret))

-- | The main API for generating CFGs for a Crucible function.
--
--   The given @FunctionDef@ action is run to generate a registerized
--   CFG.  The return value of this action is the generated CFG, and a
--   list of CFGs for any other auxiliary function definitions
--   generated along the way (e.g., for anonymous or inner functions).
defineFunction :: Position                 -- ^ Source position for the function
               -> FnHandle init ret        -- ^ Handle for the generated function
               -> FunctionDef h t init ret -- ^ Generator action and initial state
               -> ST h (SomeCFG init ret, [AnyCFG]) -- ^ Generated CFG and inner function definitions
defineFunction p h f = seq h $ do
  let argTypes = handleArgTypes h
  let c () = return

  let inputs = mkInputAtoms p argTypes
  let inputSet = Set.fromList (toListFC (Some . AtomValue) inputs)
  let (init_state, action) = f $! inputs
  let cbs = initCurrentBlockState inputSet (LabelID (Label 0))
  let ts = GS { _gsBlocks = Seq.empty
              , _gsNextLabel = 1
              , _gsNextValue  = Ctx.sizeInt (Ctx.size argTypes)
              , _gsCurrent = Just cbs
              , _gsPosition = p
              , _gsState = init_state
              , _seenFunctions = []
              }
  let go = returnFromFunction =<< action
  ts' <- runStateContT (unGenerator go) c $! ts
  return (SomeCFG (cfgFromGenerator h ts'), ts'^.seenFunctions)
